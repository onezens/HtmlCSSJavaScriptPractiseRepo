<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<div>
    <ul class="list" id="list">
        <li>hahaha1</li>
        <li>hahaha2</li>
        <li>hahaha3</li>
    </ul>
</div>
<button onclick="removeLastNode()">remove last node</button>
<script>
    var element = document.getElementById("list");
    //父亲节点
    console.log(element.parentNode);
    //子节点
    var nodes = element.childNodes;
    console.log(nodes); //默认火狐 谷歌等高本版会把换行也看做是子节点
    var children = element.children;
    console.log(children); //没有回车这些节点
    //下一个兄弟节点
    console.log(nodes[0].nextElementSibling);
    //上一个兄弟节点
    console.log(nodes[3].previousElementSibling); //有回车会自动过滤掉
    //第一个孩子节点
    console.log("firstElementChild : " + element.firstElementChild); //过滤回车
    console.log(element.firstElementChild);
    console.log("firstChild : " + element.firstChild); //不会过滤回车
    console.log(element.firstChild);
    //最后一个孩子节点 过滤效果和上相似
    console.log("lastElementChild : " + element.lastElementChild);
    console.log(element.lastElementChild);
    console.log("lastChild : " + element.lastChild);
    console.log(element.lastChild);

    //创建节点
    var newLi = document.createElement("li");
    console.log("newLi:");
    console.log(newLi);
    //插入节点appendChild();   放到盒子的最后面
    newLi.innerHTML = "appendChild";
    element.appendChild(newLi);
    //insertBefore(插入的节点，参照节点) 参照节点为空,则放到盒子的最后面
    newLi = document.createElement("li");
    newLi.innerHTML = "insertBefore";
    element.insertBefore(newLi, children[0]);
    //移除孩子节点removeChild()
    function removeLastNode(){
        if(children.length==0) return;
        element.removeChild(children[children.length-1]);
    }
    //克隆节点 cloneNode(bool); 为空默认为false
    // 如果true:除了复制本盒子，还复制子节点;
    // 如果false只复制本节点不复制子节点
    console.log("cloneNode : ")
    console.log(element.cloneNode(true));
















</script>
</body>
</html>